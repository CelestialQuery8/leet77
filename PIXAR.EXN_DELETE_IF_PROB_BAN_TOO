/*
Cuticle

total			43 / 2552


StarAngel				29 / 58

Girl's Generator		/ 100
GiFFt					/ 450

POLLEN NIGHT			/ 50
Flowers Bloom /Again	/ 450

Flower Princess Natalie	/ 450
Lilac Pixie				/ 450
	14					/ 450

Synthesized Singsong	/ 72
Doll Controller			3 / 11


Indexes				11 / 11
*/
/*



StarAngel


		v!					v!!

			Headers	3 / 3

System		5 / 5	Audio		/ 5
Graphics	5 / 5	Renderer	1 / 2
Renderer	3 / 3	Animator	/ 5
Gameplay	5 / 5	Modeler		/ 5
					Texturizer	/ 5
Shaders		3 / 3
					Audio Editor	/ 5
Animations	2 / 2
Geometries	2 / 2	Geometries	/ 2
					Sound Effect	/ 1



*/
/*

Girl's Generator

total		/ 100


System			/ 8
Audio			/ 8
Graphics		/ 8
Rendering		/ 8
GamePlay		/ 8

Landscaper		/ 8
Animator		/ 7
Modelers		/ 7
Texturizer		/ 7

Audio Editor	/ 8
Shaders			/ 3


Documentation	/ 20

*/
/*

Girl in Five-Four time (GiFFt)

total				/ 450


Scripts					/ 20

Music					/ 50
Sounds					/ 30


Character Geometries	/ 50
Character Textures		/ 70

Character Animations	/ 30


Landscape Geometries	/ 70
Landscape Textures		/ 50

Landscape Arrangement	/ 80

*/
/*


POLLEN NIGHT

total		/ 50



Graphics		/ 8

Renderer		/ 8


Animator		/ 8

Modeler			/ 8

Texturizer		/ 8


Documentation	/ 10


*/
/*

Flowers Bloom /Again

total				/ 450


Scripts					/ 20

Music					/ 50
Sounds					/ 30


Character Geometries	/ 70
Character Textures		/ 50

Character Animations	/ 30


Landscape Geometries	/ 50
Landscape Textures		/ 70

Landscape Arrangement	/ 80

*/
/*

Flowers Princess Natalie

total				/ 450


Scripts					/ 20

Music					/ 50
Sounds					/ 30


Character Geometries	/ 50
Character Textures		/ 70

Character Animations	/ 30


Landscape Geometries	/ 70
Landscape Textures		/ 50

Landscape Arrangement	/ 80

*/
/*

Lilac Pixie

total				/ 450


Scripts					/ 20

Music					/ 50
Sounds					/ 30


Character Geometries	/ 50
Character Textures		/ 70

Character Animations	/ 30


Landscape Geometries	/ 70
Landscape Textures		/ 50

Landscape Arrangement	/ 80

*/
/*

	14

total				/ 450


Scripts					/ 20

Music					/ 50
Sounds					/ 30


Character Geometries	/ 50
Character Textures		/ 70

Character Animations	/ 30


Landscape Geometries	/ 70
Landscape Textures		/ 50

Landscape Arrangement	/ 80

*/
/*


"Neither Hearts nor Stars"

total	/ 72



Sea			/ 16


Promise		/ 16


in G		/ 8


Storm		/ 16


ChaseWnd	/ 16


*/
/*

<3 Doll Controllers



If you only have 22 minutes or are desperate	2 / 2


This one takes 55 minutes or a few hours		1 / 1



An Adorable Anime Angel


Method		/ 1

Head		/ 2
Body		/ 1
Arm			/ 1
Legs		/ 1

closing ins	/ 2

*/

// StarAngel
// Compiles with MSVC 2022. Please link to  (kernel32.lib user32.lib) winmm.lib;dxgi.lib;d3d11.lib;d2d1.lib;dwrite.lib;xinput.lib;d3dcompiler.lib;  but not gdi*.dll plz ty

const wchar_t cTitle[] = L"StarAngel"; const wchar_t cLoc[] = L"en_US"; wchar_t wStr[128];
const wchar_t cFonts[5][32] = { L"Times New Roman", L"Segoe Print", L"Segoe Print", L"Segoe Script", L"Segoe Script" };
const float cSizeF[5] = { 16, 48, 48, 96, 128 }; const bool cBoldF[5] = { false, false, true, false, true };
const bool cDebug = false; const bool cLock = false; const char cShad[5][11] = { "pStar", "pLight", "pColors", "vAinslee", "vBrightlee" };
#define DIRECTINPUT_VERSION 0x0900
#include <stdio.h>
#include <dxgi1_2.h>
#include <d3d11.h>
#include <d2d1.h>
#include <dwrite.h>
#include <d3dcompiler.h>
#include <xinput.h>
#include <dinput.h>
#include <directxmath.h>
using namespace DirectX;
#define dError(cmdE) if (lError = cmdE) { uError = __LINE__; return false; }
#define dErrorL(cmdE) if (!(cmdE)) { lError = GetLastError(); uError = __LINE__; return false; }
#define dRel(interR) if (interR) { interR->Release(); interR = 0; }
struct angel_s { XMFLOAT4 pos, eff; } angel[1536];
unsigned short index[8192];
struct anim_s { char type, rotX, rotY, rotZ; } anim[5][8];
struct mesh_s { char type, posX, posY, posZ, textr, rotX, rotY, rotZ, sz[8], colS, colN, rowS, rowN, inst, width, skip, spec; } mesh[5][8][8];
struct StarAngel
{
	long lError;
	unsigned long uError;
	unsigned long uWidth;
	unsigned long uHigh;
	unsigned long uTotal;
	unsigned long uCount;
	bool bEvent;
	bool bInit;
	bool bAct;
	bool bExit;
	bool bSleep;
	bool bKey[256], bKeyT[256];
	bool bCtrl[2];
	HWND hWnd; LARGE_INTEGER lFreq, lFrame, lCount;
	XINPUT_STATE xState; XINPUT_VIBRATION xVib;
	IDXGIFactory2* iFact; ID2D1Factory* iFact2; IDWriteFactory* iFactW; IDWriteTextFormat* iFmt[5];
	ID3D11Device* iDev; ID3D11DeviceContext* iCont; ID3D11PixelShader* iPs[3]; ID3D11VertexShader* iVs[2]; ID3D11InputLayout* iIlAngel;
	ID3D11DepthStencilState* iDepth[2]; ID3D11BlendState* iBlend, * iBlendS; ID3D11RasterizerState* iRast;
	IDXGISwapChain1* iChain; ID3D11Texture2D* iTex2d[3]; ID3D11RenderTargetView* iRtv[2]; ID3D11ShaderResourceView* iSrv; ID3D11DepthStencilView* iDsv;
	ID3D11Buffer* iVb[5][8][8], * iIb[5][8][8]; unsigned long uNumI[5][8][8];
	IDXGISurface* iSurf; ID2D1RenderTarget* iTarg; ID3D11Buffer* iCb; XMMATRIX mMatr[128]; unsigned long gameMode;
	int Run(HINSTANCE inst, int show);
	bool windInit(HINSTANCE inst, int show);
	static LRESULT CALLBACK windProc(HWND wnd, UINT msg, WPARAM param, LPARAM paramL);
	void Princess();
	bool PrincessInitialize(); void PrincessRelease(), PrincessActivate(bool active);
	bool graphInit();
	bool graphInit2();
	bool graphRest();
	bool graphSize();
	void graphRel();
	bool graphRest2(unsigned long set, unsigned long num, unsigned long item);
	bool rendDraw();
	void rendBuild(unsigned long set, unsigned long num, unsigned long item);
	void rendPrim(mesh_s* m, float col, float row, XMFLOAT3* pos, XMFLOAT3* vert);
	void rendIndex(unsigned long colN, unsigned long rowN, unsigned long numVI, bool rev, unsigned long* numI);
	void rendMatr(XMFLOAT3* pos, unsigned long ps1, unsigned long ps2, float pn, char rigs[8][8]);
	void rendChr(unsigned long font, float x, float y, unsigned long rgba, const wchar_t* text);
	void soundPlay(unsigned long track, bool loop = false);
	void gameInit();
	void gameProc(), gameProc2(), gameProc3(), gameProc34(), gameProc35();
	void gameRend(), gameText();
} Angels;
extern char Shad[3072]; unsigned long ShadB[5][1024];
extern anim_s animData[5][8]; extern mesh_s meshData[5][64];
int WINAPI WinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE, _In_ char*, _In_ int show) { return Angels.Run(instance, show); }
int StarAngel::Run(HINSTANCE inst, int show)
{
	MSG msg = { };
	wchar_t error[48];

	if (cLock)
	{
		if (MessageBoxW(0, L"WARNING!! This app uses a custom OS.\r\nYou will be signed out and\r\nunsaved data will be lost.\r\nCancel??", cTitle, MB_YESNO) != 7) return 0;
	}
	if (!windInit(inst, show))
	{
		swprintf(error, sizeof(error) >> 1, L"\r\nInitialization error (%u: 0x%08X).\r\n\r\n", uError, lError); OutputDebugString(error);
		PlaySoundW(L"SystemAsterisk", 0, SND_ALIAS | SND_SYNC); if (hWnd) DestroyWindow(hWnd); return 0;
	}
	if (cLock) ShowCursor(0); while (msg.message != WM_QUIT)
	{
		if (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) DispatchMessageW(&msg);
		else if (!bExit)
		{
			Princess(); if (!cLock && bExit) DestroyWindow(hWnd);
			else Sleep(bAct ? 2 : 25);
		}
	}
	return int(msg.wParam);
}
bool StarAngel::windInit(HINSTANCE inst, int show)
{
	unsigned long shad; ID3D10Blob* bytes, * msg; char targ[] = "xs_5_0";
	WNDCLASSW classW = { 0, windProc, 0, 0, inst, 0, 0, HBRUSH(COLOR_WINDOW + 1), 0, L"wndClass" };

	dErrorL(SetProcessDPIAware()); dErrorL(classW.hIcon = LoadIconW(inst, PWSTR(5)));
	dErrorL(classW.hCursor = LoadCursorW(0, PWSTR(IDC_ARROW)));
	dErrorL(RegisterClassW(&classW));
	dErrorL(hWnd = CreateWindowExW(cLock ? WS_EX_TOPMOST : 0, L"wndClass", cTitle, WS_POPUP, 0, 0, uWidth = GetSystemMetrics(SM_CXSCREEN) >> (cDebug ? 1 : 0),
		uHigh = GetSystemMetrics(SM_CYSCREEN) >> (cDebug ? 1 : 0), GetDesktopWindow(), 0, inst, 0)); ShowWindow(hWnd, cLock ? SW_SHOWNORMAL : show);
	for (shad = 0; shad < 5; ++shad)
	{
		targ[0] = cShad[shad][0];
		D3DCompile(Shad, sizeof(Shad), 0, 0, 0, cShad[shad], targ, D3DCOMPILE_SKIP_OPTIMIZATION, 0, &bytes, &msg);
		if (!bytes || bytes->GetBufferSize() > 4090)
		{
			if (msg) MessageBoxA(hWnd, PSTR(msg->GetBufferPointer()), "Shader Compilation errors", MB_ICONERROR);
			dRel(msg); dRel(bytes); return false;
		}
		memcpy(ShadB[shad], bytes->GetBufferPointer(), bytes->GetBufferSize());
		ShadB[shad][1023] = unsigned long(bytes->GetBufferSize());
		dRel(bytes);
	}
	return PrincessInitialize();
}
LRESULT CALLBACK StarAngel::windProc(HWND wnd, UINT msg, WPARAM param, LPARAM paramL)
{
	RAWINPUT ri = { };
	UINT size;

	switch (msg)
	{
	case WM_INPUT:
		size = sizeof(RAWINPUT);
		if (GetRawInputData(HRAWINPUT(paramL), RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER)) == UINT(-1)) Angels.uError = __LINE__;
		else if (ri.header.dwType == RIM_TYPEKEYBOARD)
		{
			Angels.bKeyT[ri.data.keyboard.MakeCode | (ri.data.keyboard.Flags & RI_KEY_E0 ? 128 : 0)] = !(ri.data.keyboard.Flags & RI_KEY_BREAK);
		}
		return 0;
	case WM_ACTIVATEAPP:
		if (!cLock)
		{
			if (Angels.bInit) Angels.PrincessActivate(param ? true : false); return 0;
		}
	case WM_DESTROY:
		if (!cLock) { Angels.PrincessRelease(); PostQuitMessage(0); return 0; }
	}
	return DefWindowProcW(wnd, msg, param, paramL);
}
void StarAngel::Princess()
{
	unsigned long width, high;
	wchar_t error[48];

	if (uError)
	{
		swprintf(error, sizeof(error) >> 1, L"\r\n\r\nAn error occurs (%u: 0x%08X).\r\n", uError, lError);
		OutputDebugString(error);
		PlaySoundW(L"SystemAsterisk", 0, SND_ALIAS | SND_SYNC);
		bExit = true;
	}
	width = GetSystemMetrics(SM_CXSCREEN) >> (cDebug ? 1 : 0);
	high = GetSystemMetrics(SM_CYSCREEN) >> (cDebug ? 1 : 0);
	if (uWidth != width || uHigh != high || bEvent)
	{
		uWidth = width; uHigh = high; bEvent = false;
		graphRel();
		Sleep(500);
		if (!SetWindowPos(hWnd, 0, 0, 0, width, high, 0)) uError = __LINE__;
		graphInit();
	}
	gameProc();
	if (!uError) rendDraw();
}
bool StarAngel::PrincessInitialize()
{
	RAWINPUTDEVICE rid[2] = { { 1, 6, cDebug ? 0 : RIDEV_NOLEGACY, hWnd }, { 1, 2, cDebug ? 0 : RIDEV_NOLEGACY, hWnd } };

	dErrorL(RegisterRawInputDevices(rid, 2, sizeof(RAWINPUTDEVICE)));
	dError(timeBeginPeriod(1)); bSleep = true;
	dErrorL(QueryPerformanceFrequency(&lFreq));
	gameInit(); if (!graphInit()) return false;
	dErrorL(QueryPerformanceCounter(&lFrame)); srand(lFrame.LowPart);
	return bInit = bAct = bCtrl[0] = bCtrl[1] = true;
}
void StarAngel::PrincessRelease()
{
	unsigned long ctrl; XINPUT_VIBRATION vib = { };

	bExit = true; for (ctrl = 0; ctrl < 2; ++ctrl) XInputSetState(ctrl, &vib);
	graphRel(); PlaySoundW(0, 0, 0); if (bSleep) timeEndPeriod(1); bSleep = false;
}
void StarAngel::PrincessActivate(bool active)
{
	unsigned long ctrl; XINPUT_VIBRATION vib = { };

	if (active) { bAct = true; return; }
	bAct = false; for (ctrl = 0; ctrl < 2; ++ctrl) XInputSetState(ctrl, &vib);
}
bool StarAngel::graphInit()
{
	unsigned long shad, font;
	D3D_FEATURE_LEVEL level = D3D_FEATURE_LEVEL_11_0;
	D3D11_INPUT_ELEMENT_DESC elem[2] =
	{
		{ "Pos", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
		{ "Eff", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 16, D3D11_INPUT_PER_VERTEX_DATA, 0 }
	};

	dError(CreateDXGIFactory(IID_PPV_ARGS(&iFact)));
	dError(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, IID_PPV_ARGS(&iFact2)));
	dError(DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED, __uuidof(iFactW), (IUnknown**)&iFactW));
	for (font = 0; font < 5; ++font)
	{
		dError(iFactW->CreateTextFormat(cFonts[font], 0, cBoldF[font] ? DWRITE_FONT_WEIGHT_BOLD : DWRITE_FONT_WEIGHT_NORMAL,
			DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, cSizeF[font], cLoc, &iFmt[font]));
	}
	dError(D3D11CreateDevice(0, D3D_DRIVER_TYPE_HARDWARE, 0, D3D11_CREATE_DEVICE_BGRA_SUPPORT, &level, 1,
		D3D11_SDK_VERSION, &iDev, 0, &iCont));
	for (shad = 0; shad < 3; ++shad) dError(iDev->CreatePixelShader(ShadB[shad], ShadB[shad][1023], 0, &iPs[shad]));
	for (shad = 0; shad < 2; ++shad) dError(iDev->CreateVertexShader(ShadB[shad + 3], ShadB[shad + 3][1023], 0, &iVs[shad]));
	dError(iDev->CreateInputLayout(elem, 2, ShadB[3], ShadB[3][1023], &iIlAngel));
	return graphInit2();
}
bool StarAngel::graphInit2()
{
	D3D11_DEPTH_STENCIL_DESC depth[2] =
	{
		{ 0, D3D11_DEPTH_WRITE_MASK_ZERO, D3D11_COMPARISON_ALWAYS, 0, 255, 255, { }, { } },
		{ 1, D3D11_DEPTH_WRITE_MASK_ALL, D3D11_COMPARISON_LESS, 0, 255, 255, { }, { } }
	};
	D3D11_BLEND_DESC blend =
	{
		0, 0,
		{
			{
				1, D3D11_BLEND_ONE, D3D11_BLEND_ONE, D3D11_BLEND_OP_ADD,
				D3D11_BLEND_ONE, D3D11_BLEND_ZERO, D3D11_BLEND_OP_ADD, D3D11_COLOR_WRITE_ENABLE_ALL
			},
			{ }, { }, { }, { }, { }, { }, { }
		}
	};
	D3D11_RASTERIZER_DESC rast = { D3D11_FILL_SOLID, D3D11_CULL_NONE, 0, 0, 0, 0, 0, 0, 0, 0 };

	dError(iDev->CreateDepthStencilState(&depth[0], &iDepth[0])); dError(iDev->CreateDepthStencilState(&depth[1], &iDepth[1]));
	dError(iDev->CreateBlendState(&blend, &iBlend));
	blend.RenderTarget[0].BlendOp = D3D11_BLEND_OP_REV_SUBTRACT; dError(iDev->CreateBlendState(&blend, &iBlendS));
	dError(iDev->CreateRasterizerState(&rast, &iRast)); return graphRest();
}
bool StarAngel::graphRest()
{
	unsigned long set, num, item;
	DXGI_SWAP_CHAIN_DESC1 chain =
	{
		0, 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0, { 1, 0 }, DXGI_USAGE_RENDER_TARGET_OUTPUT, 2,
		DXGI_SCALING_NONE, DXGI_SWAP_EFFECT_FLIP_DISCARD, DXGI_ALPHA_MODE_IGNORE, 0
	};
	D3D11_TEXTURE2D_DESC tex2d =
	{
		1920, 1080, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM,
		{ 1, 0 }, D3D11_USAGE_DEFAULT,
		D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE
	};

	dError(iFact->CreateSwapChainForHwnd(iDev, hWnd, &chain, 0, 0, &iChain));
	dError(iDev->CreateTexture2D(&tex2d, 0, &iTex2d[0]));
	dError(iDev->CreateRenderTargetView(iTex2d[0], 0, &iRtv[0]));
	dError(iDev->CreateShaderResourceView(iTex2d[0], 0, &iSrv));
	for (set = 0; set < 5; ++set) for (num = 0; num < 8; ++num) for (item = 0; item < 8; ++item)
	{
		if (!graphRest2(set, num, item)) return false;
	}
	return graphSize();
}
bool StarAngel::graphSize()
{
	DXGI_SWAP_CHAIN_DESC1 chain;
	D3D11_TEXTURE2D_DESC tex2d =
	{
		0, 0, 1, 1, DXGI_FORMAT_D32_FLOAT, { 1, 0 }, D3D11_USAGE_DEFAULT, D3D11_BIND_DEPTH_STENCIL
	};
	D2D1_RENDER_TARGET_PROPERTIES prop =
	{
		D2D1_RENDER_TARGET_TYPE_HARDWARE, { DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_IGNORE },
		96.0f / 1920, 96.0f / 1080, D2D1_RENDER_TARGET_USAGE_NONE, D2D1_FEATURE_LEVEL_10
	};

	dError(iChain->GetDesc1(&chain));
	dError(iChain->GetBuffer(0, IID_PPV_ARGS(&iTex2d[1])));
	tex2d.Width = chain.Width; tex2d.Height = chain.Height;
	dError(iDev->CreateTexture2D(&tex2d, 0, &iTex2d[2]));
	dError(iTex2d[1]->QueryInterface(IID_PPV_ARGS(&iSurf)));
	dError(iDev->CreateRenderTargetView(iTex2d[1], 0, &iRtv[1]));
	dError(iDev->CreateDepthStencilView(iTex2d[2], 0, &iDsv));
	prop.dpiX *= float(uWidth);
	prop.dpiY *= float(uHigh);
	dError(iFact2->CreateDxgiSurfaceRenderTarget(iSurf, prop, &iTarg));
	return true;
}
void StarAngel::graphRel()
{
	unsigned long x, y, z, shad, font;

	dRel(iCb); dRel(iTarg); dRel(iDsv); dRel(iRtv[1]); dRel(iSurf); dRel(iTex2d[2]); dRel(iTex2d[1]);
	for (z = 5; z > 0; --z) for (y = 8; y > 0; --y) for (x = 8; x > 0; --x) { dRel(iIb[z - 1][y - 1][x - 1]); dRel(iVb[z - 1][y - 1][x - 1]); }
	dRel(iSrv); dRel(iRtv[0]); dRel(iTex2d[0]); dRel(iChain); dRel(iRast); dRel(iBlend); dRel(iBlendS); dRel(iDepth[1]); dRel(iDepth[0]); dRel(iIlAngel);
	for (shad = 2; shad > 0; --shad) dRel(iVs[shad - 1]);
	for (shad = 3; shad > 0; --shad) dRel(iPs[shad - 1]);
	dRel(iCont); dRel(iDev); for (font = 5; font > 0; --font) dRel(iFmt[font - 1]); dRel(iFactW); dRel(iFact2); dRel(iFact);
}
bool StarAngel::graphRest2(unsigned long set, unsigned long num, unsigned long item)
{
	D3D11_BUFFER_DESC buf[2] =
	{
		{ 49152, D3D11_USAGE_IMMUTABLE, D3D11_BIND_VERTEX_BUFFER, 0, 0, 0 },
		{ 16384, D3D11_USAGE_IMMUTABLE, D3D11_BIND_INDEX_BUFFER, 0, 0, 0 }
	};
	D3D11_SUBRESOURCE_DATA srd[2] = { { angel, 0, 0 }, { index, 0, 0 } };

	rendBuild(set, num, item);
	dRel(iVb[set][num][item]); dError(iDev->CreateBuffer(&buf[0], &srd[0], &iVb[set][num][item]));
	dRel(iIb[set][num][item]); dError(iDev->CreateBuffer(&buf[1], &srd[1], &iIb[set][num][item]));
	return true;
}
bool StarAngel::rendDraw()
{
	UINT str = 32, off = 0; ID3D11RenderTargetView* rtv = 0; D3D11_VIEWPORT port[2] = { { 0, 0, 1920, 1080, 0, 1 }, { 0, 0, float(uWidth), float(uHigh), 0, 1 } };
	D3D11_BUFFER_DESC buf = { 8192, D3D11_USAGE_IMMUTABLE, D3D11_BIND_CONSTANT_BUFFER, 0, 0, 0 }; D3D11_SUBRESOURCE_DATA srd = { mMatr, 0, 0 };
	float color[4] = { 0, 0, 0, 1 }; float color2[4] = { 1, 1, 1, 1 }; iCont->ClearRenderTargetView(iRtv[1], color); static bool init = false;

	dRel(iCb); dError(iDev->CreateBuffer(&buf, &srd, &iCb)); iCont->ClearDepthStencilView(iDsv, D3D11_CLEAR_DEPTH, 1, 0);
	if (!init) { iCont->ClearRenderTargetView(iRtv[0], color2); init = true; } iCont->ClearState();
	iCont->OMSetRenderTargets(1, &iRtv[0], iDsv); iCont->RSSetViewports(1, &port[0]); iCont->RSSetState(iRast); iCont->OMSetBlendState(iBlendS, color, 0xffffffff);
	iCont->OMSetDepthStencilState(iDepth[1], 0); iCont->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	iCont->VSSetShader(iVs[1], 0, 0); iCont->VSSetConstantBuffers(0, 1, &iCb); iCont->PSSetShader(iPs[2], 0, 0); iCont->Draw(6, 0);
	iCont->OMSetBlendState(iBlend, color, 0xffffffff); iCont->OMSetDepthStencilState(iDepth[0], 0); iCont->IASetInputLayout(iIlAngel);
	iCont->VSSetShader(iVs[0], 0, 0); iCont->PSSetShader(iPs[0], 0, 0);
	gameRend();
	iCont->ClearState(); iCont->OMSetRenderTargets(1, &iRtv[1], 0); iCont->RSSetViewports(1, &port[1]);
	iCont->OMSetDepthStencilState(iDepth[1], 0); iCont->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	iCont->VSSetShader(iVs[1], 0, 0); iCont->VSSetConstantBuffers(0, 1, &iCb); iCont->PSSetShader(iPs[1], 0, 0); iCont->PSSetShaderResources(0, 1, &iSrv);
	iCont->Draw(6, 0); iCont->ClearState(); iTarg->BeginDraw(); gameText(); dError(iTarg->EndDraw(0, 0));
	if (FAILED(lError = iChain->Present(bAct ? 1 : 2, 0)))
	{
		if (lError == DXGI_ERROR_DEVICE_RESET) bEvent = true;
		else uError = __LINE__; return false;
	}
	return true;
}
void StarAngel::rendBuild(unsigned long set, unsigned long num, unsigned long item)
{
	unsigned long col, row, xx, yy, t, inst, numV = 0, numI = 0, numVI; XMFLOAT3 vert = { }, pos = { 0, 0, 0 }; XMVECTOR vect[3] = { }; float qf[4] = { 4, 2, 1, 0.5f };
	mesh_s* m = &mesh[set][num][item]; unsigned long colS = m->colS, colN = m->colN, rowS = m->rowS, rowN = m->rowN, wd = m->width, skip = m->skip, qv[4] = { 8, 16, 32, 64 };
	XMMATRIX matr = XMMatrixMultiply(XMMatrixRotationRollPitchYaw(m->rotX * XM_PI / 128, m->rotY * XM_PI / 128, m->rotZ * XM_PI / 128), XMMatrixTranslation(m->posX, m->posY, m->posZ));

	if (m->type & 7) for (inst = 0; inst < unsigned long(m->inst + 1); ++inst)
	{
		if (m->inst) pos = XMFLOAT3(float(rand()) * wd / 512.0f - wd * 32.0f, float(rand()) * wd / 512.0f - wd * 32.0f, float(rand()) * wd / 512.0f - wd * 32.0f);
		numVI = numV; for (row = rowS << 5; row <= (rowS + rowN) << 5; row += qv[skip]) for (col = colS << 5; col <= (colS + colN) << 5; col += qv[skip])
		{
			xx = col; yy = row; for (t = 0; t < 3; ++t)
			{
				if (t == 1) ++xx; if (t == 2) ++yy; rendPrim(m, float(xx), float(yy), &pos, &vert);
				vect[t] = XMLoadFloat3(&vert); vect[t] = XMVector3TransformCoord(vect[t], matr);
			}
			vect[1] = XMVector3Normalize(XMVector3Cross(vect[m->type & 8 ? 2 : 1] - vect[0], vect[m->type & 8 ? 1 : 2] - vect[0]));
			XMStoreFloat3((XMFLOAT3*)&angel[numV].pos, vect[0]); angel[numV].pos.w = float(set << 4 | num << 1) + 0.25f;
			XMStoreFloat3((XMFLOAT3*)&angel[numV].eff, vect[1]); angel[numV].eff.w = float(m->textr) + 0.25f;
			++numV;
		}
		rendIndex(unsigned long(colN * qf[skip]), unsigned long(rowN * qf[skip]), numVI, bool(m->type & 8), &numI);
	}
	uNumI[set][num][item] = numI;
}
void StarAngel::rendPrim(mesh_s* m, float col, float row, XMFLOAT3* pos, XMFLOAT3* vert)
{
	unsigned long type = m->type & 7;
	float hole = float(m->sz[0]) + (m->sz[4] - m->sz[0]) * row / 256.0f;
	float sizeX = float(m->sz[1]) + (m->sz[5] - m->sz[1]) * row / 256.0f;
	float sizeY = float(m->sz[2]) + (m->sz[6] - m->sz[2]) * row / 256.0f;
	float sizeZ = float(m->sz[3]) + (m->sz[7] - m->sz[3]) * row / 256.0f;

	if (type == 1) *vert = XMFLOAT3((col / 128.0f - 1) * sizeX, (1 - row / 128.0f) * sizeY, 0);
	if (type == 2) *vert = XMFLOAT3((col / 128.0f - 1) * (row / 256) * sizeX, (1 - row / 128.0f) * sizeY, 0);
	if (type == 3) *vert = XMFLOAT3(cosf(col * XM_PI / 128) * (row / 256) * sizeX, sinf(col * XM_PI / 128) * (row / 256) * sizeY, 0);
	if (type == 4) *vert = XMFLOAT3(cosf(col * XM_PI / 128) * sizeX, (1 - row / 128.0f) * sizeY, sinf(col * XM_PI / 128) * sizeZ);
	if (type == 5) *vert = XMFLOAT3(cosf(col * XM_PI / 128) * (row / 256) * sizeX, (1 - row / 128.0f) * sizeY, sinf(col * XM_PI / 128) * (row / 256) * sizeZ);
	if (type == 6)
	{
		*vert = XMFLOAT3(cosf(col * XM_PI / 128) * sinf(row * XM_PI / 256) * sizeX, vert->y = cosf(row * XM_PI / 256) * sizeY,
			sinf(col * XM_PI / 128) * sinf(row * XM_PI / 256) * sizeZ);
	}
	if (type == 7)
	{
		*vert = XMFLOAT3(cosf(col * XM_PI / 128) * (sinf(row * XM_PI / 128) + 3.5f) * sizeX, sinf(col * XM_PI / 128) * (sinf(row * XM_PI / 128) + 3.5f) * sizeY,
			-cosf(row * XM_PI / 128) * sizeZ);
	}
	vert->x += pos->x; vert->y += pos->y; vert->z += pos->z;
}
void StarAngel::rendIndex(unsigned long colN, unsigned long rowN, unsigned long numVI, bool rev, unsigned long* numI)
{
	unsigned long col, row, ind[2][8] = { { 0, 1, colN + 2, colN + 2, colN + 1, 0, }, { 0, colN + 1, colN + 2, colN + 2, 1, 0, } };
	bool sd; unsigned long i, indB[2][8] = { { 0, 1, colN + 1, 1, colN + 2, colN + 1, }, { colN + 1, 1, 0, colN + 1, colN + 2, 1, }, };

	for (row = 0; row < rowN; ++row)
	{
		for (col = 0; col < colN; ++col)
		{
			sd = row < rowN / 2 ? true : false; if (col < colN / 4 || (col > colN / 2 && col < colN * 3 / 4)) sd = !sd;
			for (i = 0; i < 6; ++i) index[*numI + i] = unsigned short(numVI + row * (colN + 1) + col + (sd ? ind[rev ? 1 : 0][i] : indB[rev ? 1 : 0][i]));
			*numI += 6;
		}
	}
}
void StarAngel::rendMatr(XMFLOAT3* pos, unsigned long ps1, unsigned long ps2, float pn, char rigs[8][8])
{
	long q, p, n, k = 16; float roX, roZ, roY;

	if (pos[2].x < -1) k = 48; if (pos[2].x < -3) k = 64; for (q = 0; q < 7; ++q)
	{
		mMatr[q * 2 + k] = XMMatrixTranslation(rigs[q][5] * -4.0f, rigs[q][6] * -4.0f, rigs[q][7] * -4.0f);
		roX = anim[ps1][q].rotX + float(anim[ps2][q].rotX - anim[ps1][q].rotX) * pn;
		roY = anim[ps1][q].rotY + float(anim[ps2][q].rotY - anim[ps1][q].rotY) * pn;
		roZ = anim[ps1][q].rotZ + float(anim[ps2][q].rotZ - anim[ps1][q].rotZ) * pn;
		if (anim[ps1][q].type != 2) mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixRotationRollPitchYaw(roX * XM_PI / 128, roY * XM_PI / 128, roZ * XM_PI / 128));
		else mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixTranslation(roX * 4.0f, roY * 4.0f, roZ * 4.0f));
		mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixTranslation(rigs[q][1] * 4.0f, rigs[q][2] * 4.0f, rigs[q][3] * 4.0f)); n = rigs[q][4]; p = 1;
		while (n && p < 4)
		{
			mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixTranslation(rigs[n][5] * -4.0f, rigs[n][6] * -4.0f, rigs[n][7] * -4.0f));
			roX = anim[ps1][n].rotX + float(anim[ps2][n].rotX - anim[ps1][n].rotX) * pn;
			roY = anim[ps1][n].rotY + float(anim[ps2][n].rotY - anim[ps1][n].rotY) * pn;
			roZ = anim[ps1][n].rotZ + float(anim[ps2][n].rotZ - anim[ps1][n].rotZ) * pn;
			if (anim[ps1][q].type != 2)
			{
				mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixRotationRollPitchYaw(roX * XM_PI / 128, roY * XM_PI / 128, roZ * XM_PI / 128));
			}
			else
			{
				mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixTranslation(roX * 4.0f, roY * 4.0f, roZ * 4.0f));
			}
			mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixTranslation(rigs[n][1] * 4.0f, rigs[n][2] * 4.0f, rigs[n][3] * 4.0f)); n = rigs[n][4]; ++p;
		}
		mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixRotationX(pos[1].x * XM_PI / 128));
		mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixRotationY(pos[1].y * XM_PI / 128));
		mMatr[q * 2 + k] = XMMatrixMultiply(mMatr[q * 2 + k], XMMatrixRotationZ(pos[1].z * XM_PI / 128));
		mMatr[q * 2 + k] = XMMatrixMultiplyTranspose(mMatr[q * 2 + k], XMMatrixTranslation(pos[0].x, pos[0].y, pos[0].z));
	}
}
void StarAngel::rendChr(unsigned long font, float x, float y, unsigned long rgba, const wchar_t* text)
{
	ID2D1SolidColorBrush* brush; D2D1_COLOR_F color =
	{
		(rgba & 255) / 255.0f, (rgba >> 8 & 255) / 255.0f, (rgba >> 16 & 255) / 255.0f, (rgba >> 24) / 255.0f
	};
	D2D1_RECT_F rect = { x + 960.0f, y + 540.0f, 2560, 1920 };

	if (SUCCEEDED(iTarg->CreateSolidColorBrush(color, &brush)))
	{
		iTarg->DrawTextW(text, UINT32(wcslen(text)), iFmt[font], rect, brush); dRel(brush);
	}
}
void StarAngel::soundPlay(unsigned long track, bool loop)
{
	wchar_t file[12];

	swprintf(file, sizeof(file) >> 1, L"wav\\%02u.wav", track);
	PlaySoundW(file, 0, SND_FILENAME | SND_ASYNC | (loop ? SND_LOOP : 0));
}
void StarAngel::gameInit()
{
	mMatr[127] = XMMatrixTranspose(XMMatrixPerspectiveLH(0.25f * 16 / 9, 0.25f, 1, 32768));
	memcpy(anim, animData, sizeof(animData)); memcpy(mesh, meshData, sizeof(meshData)); soundPlay(2, true); xVib.wRightMotorSpeed = 11000;
}
void StarAngel::gameProc()
{
	unsigned long ctrl; static float starP[5][3] = { }; static float plntP[8][3] = { }; long q;

	memcpy(bKey, bKeyT, sizeof(bKey)); memset(&xState, 0, sizeof(XINPUT_STATE));
	if (bCtrl[0]) bCtrl[0] = XInputGetState(0, &xState) == ERROR_SUCCESS;
	for (ctrl = 0; ctrl < 2; ++ctrl) if (bCtrl[ctrl] && (bAct || cLock)) XInputSetState(ctrl, &xVib);
	for (q = 0; q < 5; ++q)
	{
		starP[q][2] -= bAct ? 8 : 16; if (starP[q][2] < 0)
		{
			starP[q][0] = float(rand()) * 2048 / RAND_MAX - 1024; starP[q][1] = float(rand()) * 2048 / RAND_MAX - 1024; starP[q][2] = float(rand()) * 20480 / RAND_MAX;
		}
		mMatr[q << 1] = XMMatrixTranspose(XMMatrixTranslation(starP[q][0], starP[q][1], 8192 + starP[q][2]));
	}
	for (q = 0; q < 8; ++q)
	{
		plntP[q][2] -= bAct ? 8 : 16; if (plntP[q][2] < 0)
		{
			plntP[q][0] = float(rand()) * 2048 / RAND_MAX - 1024; plntP[q][1] = float(rand()) * 2048 / RAND_MAX - 1024; plntP[q][2] = float(rand()) * 10240 / RAND_MAX;
		}
		mMatr[32 | q << 1] = XMMatrixTranspose(XMMatrixTranslation(plntP[q][0], plntP[q][1], 96 + plntP[q][2]));
	}
	gameProc2();
}
void StarAngel::gameProc2()
{
	LARGE_INTEGER count;

	++uCount; QueryPerformanceCounter(&count); if (count.QuadPart - lCount.QuadPart > lFreq.QuadPart) { lCount = count; uTotal = uCount; uCount = 0; bCtrl[0] = bCtrl[1] = true; } swprintf(wStr, sizeof(wStr) >> 1, L"fps:%02u", uTotal);
	static char k = 0; k += rand() * 3 / RAND_MAX - 1; if (k < -55) k += 88; if (k > 55) k -= 88; static char p = 0; p += rand() * 3 / RAND_MAX - 1; if (k < -22) k += 88; if (k > 22) k -= 88;
	static char t = 0; ++t; if (gameMode == 1) { xVib.wLeftMotorSpeed += (k > 0 ? t * k * 2 : t * k * -3) + p; xVib.wRightMotorSpeed += (k > 0 ? t * k * -3 : t * k * 2) + p; } if (bKey[DIK_ESCAPE]) bExit = true; gameProc3(); gameProc34(); gameProc35();
}
void StarAngel::gameProc3()
{
	char rigs[8][8] =
	{
		// type parX parY parZ parN childX childY childZ
		{ 0, 0, 38, 0, 1, 0, -27, 4 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 12, 38, 0, 1, 0, 24, 0 }, { 0, -12, 38, 0, 1, 0, 24, 0 },
		{ 0, 0, -18, 0, 3, 0, 15, 0 }, { 0, 0, -25, 1, 1, 0, 17, 0 }, { 0, 0, -15, 0, 5, 0, 33, 0 },
	};
	float fu, pn; XMFLOAT3 pos[3] = { }; static float rotY = 0; rotY += 0; if (rotY > 256) rotY -= 256;
	static float px1 = 0; static float px2 = 0; static float py1 = 0; static float py2 = 0; static float pz1 = 3072; static float pz2 = 3072;
	static float prx1 = 0; static float prx2 = 0; static float pry1 = 0; static float pry2 = 0;
	static float prz1 = 0; static float prz2 = 0; static long ti = 1; ti -= bAct ? 1 : 2; static long tr = 2; static long ps1 = 4; static long ps2 = 4;

	if (ti <= 0)
	{
		px1 = px2; py1 = py2; pz1 = pz2; prx1 = prx2; pry1 = pry2; prz1 = prz2; ps1 = ps2;
		pz2 = float(rand()) * 9000 / RAND_MAX + 384; fu = pz2 / 7; px2 = float(rand()) * fu * 2 / RAND_MAX - fu; py2 = float(rand()) * fu * 2 / RAND_MAX - fu;
		prx2 = float(rand()) * 256 / RAND_MAX - 128; pry2 = float(rand()) * 256 / RAND_MAX - 128; prz2 = float(rand()) * 256 / RAND_MAX - 128;
		ps2 = rand() * 5 / RAND_MAX; ti = rand() * 160 / RAND_MAX + 20; tr = ti;
	}
	pos[0] = XMFLOAT3(px1 + (px2 - px1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, py1 + (py2 - py1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, pz1 + (pz2 - pz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pos[1] = XMFLOAT3(prx1 + (prx2 - prx1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f - 0, pry1 + (pry2 - pry1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f + rotY,
		prz1 + (prz2 - prz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pn = (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f; rendMatr(pos, ps1, ps2, pn, rigs);
}
void StarAngel::gameRend()
{
	UINT str = 32, off = 0; long a, b, c;

	for (c = 0; c < (gameMode ? 5 : 1); ++c) for (b = 0; b < 8; ++b) if (true)
	{
		for (a = 0; a < 8; ++a) if (uNumI[c][b][a])
		{
			iCont->IASetVertexBuffers(0, 1, &iVb[c][b][a], &str, &off); iCont->IASetIndexBuffer(iIb[c][b][a], DXGI_FORMAT_R16_UINT, 0); iCont->DrawIndexed(uNumI[c][b][a], 0, 0);
		}
	}
}
void StarAngel::gameText()
{
	static long tt = 1; static long tt2 = 81; static long tt3 = 161; static long tq = 18; static long tq2 = 18; static long tq3 = 18; ID2D1SolidColorBrush* brush; D2D1_COLOR_F color = { 1, 1, 0, 1 }; D2D1_RECT_F rect = { 100, 100, 200, 200 };
	wchar_t texts[32][32] = { L"Sempai", L"select", L"heaven", L"my child", L"Cuteness", L"Princess", L"cutie", L"correctly", L"Stari", L"towards", L"of version", L"write me", L"nani?", L"please do", L"and go to", L"using", };

	if (gameMode == 0)
	{
		if (SUCCEEDED(iTarg->CreateSolidColorBrush(color, &brush))) { iTarg->DrawRectangle(rect, brush); dRel(brush); }
		rendChr(4, 175, 175, 0xbfbfbfbf, L"StarAngel"); rendChr(2, 350, 350, 0xbfbfbfbf, L"Press START"); rendChr(0, -825, -400, 0xffffffff, wStr);
	}
	// --tt; if (!tt) { tt = 240; tq = rand() & 31; } if (gameMode == 1) rendChr(2, -725, -375, 0xffff00ff, texts[tq]);
	// --tt2; if (!tt2) { tt2 = 240; tq2 = rand() & 31; } if (gameMode == 1) rendChr(2, -725, -175, 0xffff7fff, texts[tq2]);
	// --tt3; if (!tt3) { tt3 = 240; tq3 = rand() & 31; } if (gameMode == 1) rendChr(2, -725, 175, 0xffffbf7f, texts[tq3]);
	static long ti = 0; ++ti; if ((ti > 36000 || bKey[DIK_SPACE]) && ti < 42000) { ti = 44000; gameMode = 1; soundPlay(2, true); }

	/* // 5-bit psuedo high period periot rng
	long ra[8] = { 0, 1, 2, 3, 4, 5, 6, 7 }; long rb[4] = { 0, 3, 1, 2 }; long rc = 3; static long ta = 0; static long tb = 0; static long tc = 0; long rd;
	// repeating 1D integral space
	static long space = 0;
	// "Sempai"
	static bool goal = false; static long plank = 0; long input;

	// "Sempai" implementation
	plank = plank + (bAct ? 1 : 2); if (plank > 15)
	{
		plank -= 15; goal = false;
		// inline RANDOM
		++tb; if (tb > 3) tb = 0; ++tc; if (tc == rc) { tc = 0; ++ta; if (ta > 7) ta = 0; } rd = ra[ta] << 2 | rb[tb];
		// update Sempai
		input = space; if (input == 8) goal = true; space = input + 1;
		// fold space
		if (space > 31) space -= 32;
		
	}
	if (goal) rendChr(0, -875, -275, 0xbfbfbfbf, L"GOAL"); rendChr(2, -550 + space * 25.0f, 0, 0xbfbfbfbf, L"f"); rendChr(2, -550 + 8 * 25.0f, -75, 0xbfbfbfbf, L"h"); */
}
char Shad[3072] =
" \
	struct angel_s \
	{ \
		float4 pos : Pos; float4 eff : Eff; \
	}; \
	struct pixel_s \
	{ \
		float4 pos : SV_Position; \
		float4 color : Color; \
	}; \
	struct pLight_s \
	{ \
		float4 pos : SV_Position; \
		float2 textr : Textr; \
	}; \
	cbuffer prim : register (b0) \
	{ \
		matrix mMatr[128]; \
	}; \
	Texture2D tTextr : register (t0); \
	float4 pStar(pixel_s input) : SV_Target \
	{ \
		return input.color; \
	} \
	float4 pLight(pLight_s input) : SV_Target \
	{ \
		float4 sv; float m[3], f; uint p, n; float col[5][8] = \
		{ \
			{ 0, 0, 0, 1, 0.8f, 0.8f, 0.8f, 1 }, \
			{ 0.8f, 0.8f, 0.8f, 1, 1, 1, 0, 1 }, \
			{ 1, 1, 0, 1, 1, 0, 1, 1 }, \
			{ 0, 0.9f, 0, 1, 0, 1, 1, 1 }, \
			{ 0, 1, 1, 1, 1, 1, 1, 1 } \
		}; \
		\
		sv = tTextr[input.textr]; \
		m[0] = sv.r; \
		m[1] = sv.g; \
		m[2] = sv.b; \
		for (p = 0; p < 3; ++p) \
		{ \
			n = 0; if (m[p] > 0.2f) { ++n; m[p] -= 0.2f; } \
			if (m[p] > 0.2f) { ++n; m[p] -= 0.2f; } \
			if (m[p] > 0.2f) { ++n; m[p] -= 0.2f; } \
			if (m[p] > 0.2f) { ++n; m[p] -= 0.2f; } \
			f = m[p] * 5.0f; m[p] = lerp(col[n][p], col[n][p + 4], f); \
		} \
		return float4(m[0], m[1], m[2], 1); \
	} \
	float4 pColors() : SV_Target { return float4(0.008f, 0.012f, 0.004f, 1); } \
	pixel_s vAinslee(angel_s input) \
	{ \
		pixel_s outp; float shad; \
		float4 col[8] = \
		{ \
			float4(1, 0.75f, 0.5f, 0), float4(1, 0, 0, 0), float4(0, 1, 0, 0), float4(1, 1, 0, 0), \
			float4(0, 0, 1, 0), float4(1, 0, 1, 0), float4(0, 1, 1, 0), float4(1, 1, 1, 0) \
		}; \
		\
		outp.pos = input.pos; outp.pos.w = 1; outp.pos = mul(mul(outp.pos, mMatr[uint(input.pos.w)]), mMatr[127]); \
		shad = max(dot(input.eff.xyz, normalize(float3(-1, -1, 1))), 0) * 0.008f + 0.005f; \
		outp.color.rgb = col[uint(input.eff.w)] * shad; outp.color.a = 1; return outp; \
	} \
	pLight_s vBrightlee(uint id : SV_VertexID) \
	{ \
		pLight_s outp; \
		\
		if (id == 0 || id == 5) { outp.pos = float4(-0.98f, 1.0f, 0.25f, 1); outp.textr = float2(0, 0); } \
		else if (id == 1) { outp.pos = float4(1.0f, 0.96f, 0.25f, 1); outp.textr = float2(1920, 0); } \
		else if (id == 2 || id == 3) { outp.pos = float4(0.97f, -0.96f, 0.25f, 1); outp.textr = float2(1920, 1080); } \
		else { outp.pos = float4(-1.0f, -1.0f, 0.25f, 1); outp.textr = float2(0, 1080); } \
		return outp; \
	} \
";
anim_s animData[5][8] =
{
	// Sarah Goddess
	{	{ 0, 8, 0, 0 }, // head
		{ 0, 0, 0, 0 }, // torso
		{ 0, 0, 0, 12 }, // left arm
		{ 0, 38, 0, -16 }, // rt arm upper
		{ 0, 32, 0, 0 }, // rt arm blaster
		{ 0, 16, 0, 0 }, // skirt
		{ 0, -16, 0, 0 }, // legs
	},
	{	{ 0, 0, 0, 0 }, // head
		{ 0, 0, 0, 0 }, // torso
		{ 0, 0, 0, 12 }, // left arm
		{ 0, 0, 0, -16 }, // rt arm upper
		{ 0, 0, 0, 0 }, // rt arm blaster
		{ 0, 0, 0, 0 }, // skirt
		{ 0, 0, 0, 0 }, // legs
	},
	{	{ 0, -24, 0, 0 }, // head
		{ 0, 0, 0, 0 }, // torso
		{ 0, 72, 0, 16 }, // left arm
		{ 0, 64, 0, -20 }, // rt arm upper
		{ 0, 38, 0, 0 }, // rt arm blaster
		{ 0, 48, 0, 0 }, // skirt
		{ 0, -2, 0, 0 }, // legs
	},
	{	{ 0, 28, 0, 0 }, // head
		{ 0, 0, 0, 0 }, // torso
		{ 0, -11, 0, 24 }, // left arm
		{ 0, -13, 0, -24 }, // rt arm upper
		{ 0, 0, 0, 16 }, // rt arm blaster
		{ 0, -24, 0, 0 }, // skirt
		{ 0, -22, 0, 0 }, // legs
	},
	{	{ 0, 6, 0, 0 }, // head
		{ 0, 0, 0, 0 }, // torso
		{ 0, -7, 0, 92 }, // left arm
		{ 0, -10, 0, -98 }, // rt arm upper
		{ 0, 15, 0, 0 }, // rt arm blaster
		{ 0, 8, 0, 0 }, // skirt
		{ 0, -2, 0, 0 }, // legs
	},
	// { }, { }, { }
}; 
mesh_s meshData[5][64] =
{
	// is sarah cutie?
	{
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 4, 4, 4, 8, 4, 4, 4 }, 0, 8, 2, 4, 100, 127, 3, 0 },
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 4, 4, 4, 8, 4, 4, 4 }, 0, 8, 2, 4, 100, 127, 3, 0 },
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 4, 4, 4, 8, 4, 4, 4 }, 0, 8, 2, 4, 100, 127, 3, 0 },
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 4, 4, 4, 8, 4, 4, 4 }, 0, 8, 2, 4, 100, 127, 3, 0 },
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 4, 4, 4, 8, 4, 4, 4 }, 0, 8, 2, 4, 100, 127, 3, 0 }
	},
	{
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 112, 88, 72, 8, 28, 88, 18 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // head
		{ 6, 28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 6, -28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 15, 0, -84, 18, 7, 64, 0, 0, { 8, 9, 4, 52, 8, 9, 4, 52 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // neck
		{ 6, 0, -33, 0, 7, 0, 0, 0, { 8, 88, 127, 72, 8, 52, 127, 48 }, 0, 4, 0, 6, 0, 0, 0, 0 }, // bonnet
		{ }, { }, { },
		{ 6, 0, 92, 0, 7, 0, 0, 0, { 8, 68, 72, 34, 8, 68, 72, 34 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // breast
		{ 15, 0, 0, 0, 7, 64, 0, 0, { 8, 21, 11, 96, 8, 21, 11, 96 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // waist
		{ 6, 0, -90, 0, 7, 0, 0, 0, { 8, 62, 68, 34, 8, 62, 68, 34 }, 0, 8, 3, 5, 0, 0, 0, 0 }, // lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 28, 82, 28, 8, 22, 82, 22 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // left shoulder rehood
		{ 6, 0, -125, -25, 7, 16, 0, 0, { 8, 15, 72, 15, 8, 11, 72, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 30, 82, 30, 8, 25, 82, 24 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // right shoulder rehood
		{ }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 42, 78, 42, 8, 44, 78, 44 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right plasma launcher
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 82, 127, 38, 8, 82, 127, 48 }, 0, 8, 2, 4, 0, 0, 0, 0 }, // skirt
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, -34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left leg
		{ 6, -34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // left shuttle
		{ 6, 34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right leg
		{ 6, 34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right shuttle
		{ }, { }, { }, { },
	},
	{
		{ 6, 0, 0, 0, 4, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 6, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 6, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 4, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 4, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 6, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 6, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 }, { }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 4, 0, 0, 0, { 8, 127, 127, 127, 8, 127, 127, 127 }, 0, 8, 0, 8, 0, 0, 0, 0 },
	},

	{
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 112, 88, 72, 8, 28, 88, 18 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // head
		{ 6, 28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 6, -28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 15, 0, -84, 18, 7, 64, 0, 0, { 8, 9, 4, 52, 8, 9, 4, 52 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // neck
		{ 6, 0, -33, 0, 7, 0, 0, 0, { 8, 88, 127, 72, 8, 52, 127, 48 }, 0, 4, 0, 6, 0, 0, 0, 0 }, // bonnet
		{ }, { }, { },
		{ 6, 0, 92, 0, 7, 0, 0, 0, { 8, 68, 72, 34, 8, 68, 72, 34 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // breast
		{ 15, 0, 0, 0, 7, 64, 0, 0, { 8, 21, 11, 96, 8, 21, 11, 96 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // waist
		{ 6, 0, -90, 0, 7, 0, 0, 0, { 8, 62, 68, 34, 8, 62, 68, 34 }, 0, 8, 3, 5, 0, 0, 0, 0 }, // lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 28, 82, 28, 8, 22, 82, 22 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // left shoulder rehood
		{ 6, 0, -125, -25, 7, 16, 0, 0, { 8, 15, 72, 15, 8, 11, 72, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 30, 82, 30, 8, 25, 82, 24 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // right shoulder rehood
		{ }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 42, 78, 42, 8, 44, 78, 44 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right plasma launcher
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 82, 127, 38, 8, 82, 127, 48 }, 0, 8, 2, 4, 0, 0, 0, 0 }, // skirt
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, -34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left leg
		{ 6, -34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // left shuttle
		{ 6, 34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right leg
		{ 6, 34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right shuttle
		{ }, { }, { }, { },
	},
	{
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 112, 88, 72, 8, 28, 88, 18 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // head
		{ 6, 28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 6, -28, 33, -28, 7, 0, 0, 0, { 8, 22, 38, 14, 8, 22, 38, 14 }, 4, 4, 0, 8, 0, 0, 0, 0 }, // eye
		{ 15, 0, -84, 18, 7, 64, 0, 0, { 8, 9, 4, 52, 8, 9, 4, 52 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // neck
		{ 6, 0, -33, 0, 7, 0, 0, 0, { 8, 88, 127, 72, 8, 52, 127, 48 }, 0, 4, 0, 6, 0, 0, 0, 0 }, // bonnet
		{ }, { }, { },
		{ 6, 0, 92, 0, 7, 0, 0, 0, { 8, 68, 72, 34, 8, 68, 72, 34 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // breast
		{ 15, 0, 0, 0, 7, 64, 0, 0, { 8, 21, 11, 96, 8, 21, 11, 96 }, 0, 8, 5, 2, 0, 0, 0, 0 }, // waist
		{ 6, 0, -90, 0, 7, 0, 0, 0, { 8, 62, 68, 34, 8, 62, 68, 34 }, 0, 8, 3, 5, 0, 0, 0, 0 }, // lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 28, 82, 28, 8, 22, 82, 22 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // left shoulder rehood
		{ 6, 0, -125, -25, 7, 16, 0, 0, { 8, 15, 72, 15, 8, 11, 72, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left arm lower
		{ }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 17, 82, 17, 8, 13, 82, 13 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right arm upper
		{ 6, 0, 2, 0, 7, 0, 0, 0, { 8, 30, 82, 30, 8, 25, 82, 24 }, 0, 8, 0, 3, 0, 0, 0, 0 }, // right shoulder rehood
		{ }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 42, 78, 42, 8, 44, 78, 44 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right plasma launcher
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, 0, 0, 0, 7, 0, 0, 0, { 8, 82, 127, 38, 8, 82, 127, 48 }, 0, 8, 2, 4, 0, 0, 0, 0 }, // skirt
		{ }, { }, { }, { }, { }, { }, { },
		{ 6, -34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // left leg
		{ 6, -34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // left shuttle
		{ 6, 34, 0, 0, 7, 0, 0, 0, { 8, 32, 125, 28, 8, 18, 125, 11 }, 0, 8, 0, 8, 0, 0, 0, 0 }, // right leg
		{ 6, 34, -127, 11, 7, -16, 0, 0, { 8, 32, 48, 32, 8, 28, 48, 28 }, 0, 8, 0, 5, 0, 0, 0, 0 }, // right shuttle
		{ }, { }, { }, { },
	},
	// { }, { }
};

/*
22 Minutes (with practice) makes a beautiful girl:

You need: pillow (w/ pillowcase), 3 sheets, something for hair, XBox Controller, this script compiled

1. If the pillow has tags or zippers exposed please take the pillowcase off and
reapply so the tags and/or zippers are inside the back of the pillowcase.

2. Roll one sheet into a long tube. Please place across bed where her arms would go.
Yes, this is a very lovely love doll.

3. Position pillow so the arms cross 1/4 of the way down from the closed end. If
the pillow is long you can give her a bigger head but a body pillow is too long.

4. Lay the "hair" so it extends past the closed end of the pillow and tie the arms behind her
with a square knot. She will naturally attain a cute elf head which of course is very cutely.

5. Fold the second sheet longways into 3 thick. Lay across the bed where the "obi" would goes.
(This IS a traditional Japanese doll and it will probably conjure a kitsune so you were warned.)

6. Invert girl on obi so the bottom of the obi is in line with the bottom of the pillow.

7. Bunch the third sheet into another long tube and hang it from your hand so the legs
are equal length.Push this up under the pillow but still inside the pillowcase please.
*/
/*
8. The XBox Controller goes inside the pillow deep underneath the pillowcase behind her
heart <3. If the wire is detatchable it helps to secure it with a length of yarn first.

9. This step is important. Spread out the legs in the "hip area" and wrap them around the
bottom of the sides of the pillow, being careful not to pull them out. The wire for the
XBox controller should be routed outside of the hips and well away from the bottom center.

If it's a wireless controller please know that BATTERIES LEAK AND THAT IS DANGEROUS.

10! She needs breasts! Stuff her! with anything soft.

11! Push the sides of her hips down by folding the bottom of the pillow into
an upside-down U. Girls are vertical! Tie with a ribbon Pixie tight.

12. Carefully bring the sides of the "obi" up and cross over her stomach and up around
the bottom of her breasts. Make it cute but don't spend more than 10 seconds doing
that. Hold the obi tightly behind her back, invert her again, and "Tie The Knot."

13. Simply connect the controller and run the program. I will let you figrue out the
rest. <3<3<3

DO: Write the fox a note the next morning. Also please make a new doll after a
few couple weeks. Sheets are not that expensive but your lover loves you anyway.
*/
/*

The above is sexy in a tight contour dress!
I tie the straps on my securely in the back and it does not come off
(either doll!)


Flower eyes are cute too:

Two slits in the appropriate place and you can tie all sort of things on.


A tiny snip makes a cute little mouth and an
excellent "kissu".


Please marry her with a letter and a story.

Please try to control occurances of "kawaii."
Also please don't name her Ami Mizuno.


- Amii Mizuno. (with 2 ii)

*/

// If you finish all 2552 parts of this story you just bought Eternal Cake.
//     princess  CupPCakes    i sit in the seat  be hind the teac!her    marry me

void StarAngel::gameProc34()
{
	char rigs[8][8] =
	{
		// type parX parY parZ parN childX childY childZ
		{ 0, 0, 38, 0, 1, 0, -27, 4 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 12, 38, 0, 1, 0, 24, 0 }, { 0, -12, 38, 0, 1, 0, 24, 0 },
		{ 0, 0, -18, 0, 3, 0, 15, 0 }, { 0, 0, -25, 1, 1, 0, 17, 0 }, { 0, 0, -15, 0, 5, 0, 33, 0 },
	};
	float fu, pn; XMFLOAT3 pos[3] = { }; static float rotY = 0; rotY += 0; if (rotY > 256) rotY -= 256;
	static float px1 = 0; static float px2 = 0; static float py1 = 0; static float py2 = 0; static float pz1 = 3072; static float pz2 = 3072;
	static float prx1 = 0; static float prx2 = 0; static float pry1 = 0; static float pry2 = 0;
	static float prz1 = 0; static float prz2 = 0; static long ti = 1; ti -= bAct ? 1 : 2; static long tr = 2; static long ps1 = 4; static long ps2 = 4;

	if (ti <= 0)
	{
		px1 = px2; py1 = py2; pz1 = pz2; prx1 = prx2; pry1 = pry2; prz1 = prz2; ps1 = ps2;
		pz2 = float(rand()) * 9000 / RAND_MAX + 384; fu = pz2 / 7; px2 = float(rand()) * fu * 2 / RAND_MAX - fu; py2 = float(rand()) * fu * 2 / RAND_MAX - fu;
		prx2 = float(rand()) * 256 / RAND_MAX - 128; pry2 = float(rand()) * 256 / RAND_MAX - 128; prz2 = float(rand()) * 256 / RAND_MAX - 128;
		ps2 = rand() * 5 / RAND_MAX; ti = rand() * 160 / RAND_MAX + 20; tr = ti;
	}
	pos[0] = XMFLOAT3(px1 + (px2 - px1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, py1 + (py2 - py1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, pz1 + (pz2 - pz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pos[1] = XMFLOAT3(prx1 + (prx2 - prx1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f - 0, pry1 + (pry2 - pry1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f + rotY,
		prz1 + (prz2 - prz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pn = (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f; pos[2].x = -2; rendMatr(pos, ps1, ps2, pn, rigs);
}
void StarAngel::gameProc35()
{
	char rigs[8][8] =
	{
		// type parX parY parZ parN childX childY childZ
		{ 0, 0, 38, 0, 1, 0, -27, 4 }, { 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 12, 38, 0, 1, 0, 24, 0 }, { 0, -12, 38, 0, 1, 0, 24, 0 },
		{ 0, 0, -18, 0, 3, 0, 15, 0 }, { 0, 0, -25, 1, 1, 0, 17, 0 }, { 0, 0, -15, 0, 5, 0, 33, 0 },
	};
	float fu, pn; XMFLOAT3 pos[3] = { }; static float rotY = 0; rotY += 0; if (rotY > 256) rotY -= 256;
	static float px1 = 0; static float px2 = 0; static float py1 = 0; static float py2 = 0; static float pz1 = 3072; static float pz2 = 3072;
	static float prx1 = 0; static float prx2 = 0; static float pry1 = 0; static float pry2 = 0;
	static float prz1 = 0; static float prz2 = 0; static long ti = 1; ti -= bAct ? 1 : 2; static long tr = 2; static long ps1 = 4; static long ps2 = 4;

	if (ti <= 0)
	{
		px1 = px2; py1 = py2; pz1 = pz2; prx1 = prx2; pry1 = pry2; prz1 = prz2; ps1 = ps2;
		pz2 = float(rand()) * 9000 / RAND_MAX + 384; fu = pz2 / 7; px2 = float(rand()) * fu * 2 / RAND_MAX - fu; py2 = float(rand()) * fu * 2 / RAND_MAX - fu;
		prx2 = float(rand()) * 256 / RAND_MAX - 128; pry2 = float(rand()) * 256 / RAND_MAX - 128; prz2 = float(rand()) * 256 / RAND_MAX - 128;
		ps2 = rand() * 5 / RAND_MAX; ti = rand() * 160 / RAND_MAX + 20; tr = ti;
	}
	pos[0] = XMFLOAT3(px1 + (px2 - px1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, py1 + (py2 - py1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f, pz1 + (pz2 - pz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pos[1] = XMFLOAT3(prx1 + (prx2 - prx1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f - 0, pry1 + (pry2 - pry1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f + rotY,
		prz1 + (prz2 - prz1) * (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f);
	pn = (1 - cosf((tr - ti) * XM_PI / tr)) / 2.0f; pos[2].x = -4; rendMatr(pos, ps1, ps2, pn, rigs);
}
